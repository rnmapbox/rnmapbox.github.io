"use strict";(self.webpackChunkmap_docs=self.webpackChunkmap_docs||[]).push([[4530],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>y});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=r.createContext({}),p=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},c=function(e){var n=p(e.components);return r.createElement(l.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),u=p(t),m=o,y=u["".concat(l,".").concat(m)]||u[m]||d[m]||a;return t?r.createElement(y,s(s({ref:n},c),{},{components:t})):r.createElement(y,s({ref:n},c))}));function y(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,s=new Array(a);s[0]=m;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i[u]="string"==typeof e?e:o,s[1]=i;for(var p=2;p<a;p++)s[p]=t[p];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},3187:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>p});var r=t(7462),o=(t(7294),t(3905));const a={title:"Draw Polyline",tags:["LineLayer","ShapeSource","onCameraChanged","getCoordinateFromView","Overlay"],custom_props:{example_rel_path:"LineLayer/DrawPolyline.tsx"},custom_edit_url:"https://github.com/rnmapbox/maps/tree/master/example/src/examples/LineLayer/DrawPolyline.tsx"},s=void 0,i={unversionedId:"examples/LineLayer/DrawPolyline",id:"examples/LineLayer/DrawPolyline",title:"Draw Polyline",description:"This example shows a simple polyline editor. It uses onCameraChanged to get the center of the map and getCoordinateFromView",source:"@site/docs/examples/LineLayer/DrawPolyline.md",sourceDirName:"examples/LineLayer",slug:"/examples/LineLayer/DrawPolyline",permalink:"/docs/examples/LineLayer/DrawPolyline",draft:!1,editUrl:"https://github.com/rnmapbox/maps/tree/master/example/src/examples/LineLayer/DrawPolyline.tsx",tags:[{label:"LineLayer",permalink:"/docs/tags/line-layer"},{label:"ShapeSource",permalink:"/docs/tags/shape-source"},{label:"onCameraChanged",permalink:"/docs/tags/on-camera-changed"},{label:"getCoordinateFromView",permalink:"/docs/tags/get-coordinate-from-view"},{label:"Overlay",permalink:"/docs/tags/overlay"}],version:"current",frontMatter:{title:"Draw Polyline",tags:["LineLayer","ShapeSource","onCameraChanged","getCoordinateFromView","Overlay"],custom_props:{example_rel_path:"LineLayer/DrawPolyline.tsx"},custom_edit_url:"https://github.com/rnmapbox/maps/tree/master/example/src/examples/LineLayer/DrawPolyline.tsx"},sidebar:"examplesSidebar",previous:{title:"Watercolor Raster Tiles",permalink:"/docs/examples/FillRasterLayer/WatercolorRasterTiles"},next:{title:"Gradient Line",permalink:"/docs/examples/LineLayer/GradientLine"}},l={},p=[],c={toc:p},u="wrapper";function d(e){let{components:n,...t}=e;return(0,o.kt)(u,(0,r.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"This example shows a simple polyline editor. It uses ",(0,o.kt)("inlineCode",{parentName:"p"},"onCameraChanged")," to get the center of the map and ",(0,o.kt)("inlineCode",{parentName:"p"},"getCoordinateFromView"),"\nto get the coordinates of the crosshair."),(0,o.kt)("p",null,"  The crosshair is an overlay that is positioned using ",(0,o.kt)("inlineCode",{parentName:"p"},"onLayout")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"getCoordinateFromView"),"."),(0,o.kt)("p",null,"  The ",(0,o.kt)("inlineCode",{parentName:"p"},"ShapeSource")," is updated with the new coordinates and the ",(0,o.kt)("inlineCode",{parentName:"p"},"LineLayer")," is updated with the new coordinates."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"import { Camera, LineLayer, MapView, ShapeSource } from '@rnmapbox/maps';\nimport { Button, View } from 'react-native';\nimport React, {\n  useState,\n  useRef,\n  ComponentProps,\n  useMemo,\n  forwardRef,\n} from 'react';\n\ntype Position = [number, number];\n\ntype CrosshairProps = {\n  size: number;\n  w: number;\n  onLayout: ComponentProps<typeof View>['onLayout'];\n};\nconst Crosshair = forwardRef<View, CrosshairProps>(\n  ({ size, w, onLayout }: CrosshairProps, ref) => (\n    <View\n      onLayout={onLayout}\n      ref={ref}\n      style={{\n        width: 2 * size + 1,\n        height: 2 * size + 1,\n      }}\n    >\n      <View\n        style={{\n          position: 'absolute',\n          left: size,\n          top: 0,\n          bottom: 0,\n          borderColor: 'red',\n          borderWidth: w / 2.0,\n        }}\n      />\n      <View\n        style={{\n          position: 'absolute',\n          top: size,\n          left: 0,\n          right: 0,\n          borderColor: 'red',\n          borderWidth: w / 2.0,\n        }}\n      />\n    </View>\n  ),\n);\n\nconst CrosshairOverlay = ({\n  onCenter,\n}: {\n  onCenter: (x: [number, number]) => void;\n}) => {\n  const ref = useRef<View>(null);\n\n  if (ref.current != null) {\n    console.log('=> ref.current', ref.current != null);\n  }\n  return (\n    <View\n      style={{\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0,\n        alignContent: 'center',\n        alignItems: 'center',\n        justifyContent: 'center',\n      }}\n      pointerEvents=\"none\"\n    >\n      <Crosshair\n        size={20}\n        w={1.0}\n        ref={ref}\n        onLayout={(e) => {\n          const { x, y, width, height } = e.nativeEvent.layout;\n          onCenter([x + width / 2.0, y + height / 2.0]);\n        }}\n      />\n    </View>\n  );\n};\n\nconst lineLayerStyle = {\n  lineColor: '#ff0000',\n};\n\nconst Polygon = ({ coordinates }: { coordinates: Position[] }) => {\n  const features: GeoJSON.FeatureCollection = useMemo(() => {\n    return {\n      type: 'FeatureCollection',\n      features: [\n        {\n          type: 'Feature',\n          id: 'a-feature',\n          geometry: {\n            type: 'LineString',\n            coordinates,\n          },\n          properties: {},\n        } as const,\n      ],\n    };\n  }, [coordinates]);\n  console.log('=> features', JSON.stringify(features));\n  return (\n    <ShapeSource id={'shape-source-id-0'} shape={features}>\n      <LineLayer id={'line-layer'} style={lineLayerStyle} />\n    </ShapeSource>\n  );\n};\n\nconst DrawPolyline = () => {\n  const [coordinates, setCoordinates] = useState<Position[]>([]);\n  const [lastCoordinate, setLastCoordinate] = useState<Position>([0, 0]);\n  const [started, setStarted] = useState(false);\n  const [crosshairPos, setCrosshairPos] = useState([0, 0]);\n\n  const coordinatesWithLast = useMemo(() => {\n    return [...coordinates, lastCoordinate];\n  }, [coordinates, lastCoordinate]);\n\n  const map = useRef<MapView>(null);\n\n  const newLocal = 'row';\n  return (\n    <View style={{ flex: 1 }}>\n      <View>\n        {!started ? (\n          <Button\n            title=\"start\"\n            onPress={() => {\n              setStarted(true);\n              setCoordinates([lastCoordinate]);\n            }}\n          />\n        ) : (\n          <View\n            style={{\n              flexDirection: newLocal,\n              justifyContent: 'center',\n              gap: 10,\n            }}\n          >\n            <Button\n              title=\"add\"\n              onPress={() => setCoordinates([...coordinates, lastCoordinate])}\n            />\n            <Button title=\"stop\" onPress={() => setStarted(false)} />\n          </View>\n        )}\n      </View>\n      <View style={{ flex: 1 }}>\n        <MapView\n          ref={map}\n          style={{ flex: 1 }}\n          onCameraChanged={async (e) => {\n            const crosshairCoords = await map.current?.getCoordinateFromView(\n              crosshairPos,\n            );\n            console.log(\n              'Crosshair coords: ',\n              crosshairCoords,\n              'camera center:',\n              e.properties.center,\n            );\n            setLastCoordinate(crosshairCoords as Position);\n            if (crosshairCoords && started) {\n              setLastCoordinate(crosshairCoords as Position);\n            }\n          }}\n        >\n          {started && <Polygon coordinates={coordinatesWithLast} />}\n          <Camera\n            defaultSettings={{\n              centerCoordinate: [-73.970895, 40.723279],\n              zoomLevel: 12,\n            }}\n          />\n        </MapView>\n        <CrosshairOverlay onCenter={(c) => setCrosshairPos(c)} />\n      </View>\n    </View>\n  );\n};\n\nexport default DrawPolyline;\n\n\n")),(0,o.kt)("p",null,"}"))}d.isMDXComponent=!0}}]);