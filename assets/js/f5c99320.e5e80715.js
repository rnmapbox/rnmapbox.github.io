"use strict";(self.webpackChunkmap_docs=self.webpackChunkmap_docs||[]).push([[6229],{3045:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>d,contentTitle:()=>i,default:()=>m,frontMatter:()=>s,metadata:()=>r,toc:()=>l});var o=t(5893),a=t(1151);const s={title:"Fit",tags:["Camera","Camera#zoomTo"],custom_props:{example_rel_path:"Camera/Fit.tsx"},custom_edit_url:"https://github.com/rnmapbox/maps/tree/master/example/src/examples/Camera/Fit.tsx"},i=void 0,r={id:"examples/Camera/Fit",title:"Fit",description:"Change camera via imperative methods",source:"@site/docs/examples/Camera/Fit.md",sourceDirName:"examples/Camera",slug:"/examples/Camera/Fit",permalink:"/docs/examples/Camera/Fit",draft:!1,unlisted:!1,editUrl:"https://github.com/rnmapbox/maps/tree/master/example/src/examples/Camera/Fit.tsx",tags:[{inline:!0,label:"Camera",permalink:"/docs/tags/camera"},{inline:!0,label:"Camera#zoomTo",permalink:"/docs/tags/camera-zoom-to"}],version:"current",frontMatter:{title:"Fit",tags:["Camera","Camera#zoomTo"],custom_props:{example_rel_path:"Camera/Fit.tsx"},custom_edit_url:"https://github.com/rnmapbox/maps/tree/master/example/src/examples/Camera/Fit.tsx"},sidebar:"examplesSidebar",previous:{title:"Offline Tilesets",permalink:"/docs/examples/CacheOffline/OfflineTilesets"},next:{title:"FlyTo",permalink:"/docs/examples/Camera/FlyTo"}},d={},l=[];function c(n){const e={code:"code",img:"img",p:"p",pre:"pre",...(0,a.a)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.p,{children:"Change camera via imperative methods"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:"import React from 'react';\nimport { View, Text, ScrollView, TouchableOpacity } from 'react-native';\nimport isEqual from 'lodash.isequal';\nimport { MapView, Camera, StyleURL, type CameraBounds } from '@rnmapbox/maps';\n\nimport sheet from '../../styles/sheet';\nimport { ExampleWithMetadata } from '../common/ExampleMetadata'; // exclude-from-doc\n\n// Assertion function to ensure camera is not null\nfunction assertCameraNotNull(camera: Camera | null): asserts camera is Camera {\n  if (!camera) {\n    throw new Error('Camera reference is null');\n  }\n}\n\nconst buildPadding = ([top, right, bottom, left] = [0, 0, 0, 0]) => {\n  return {\n    paddingLeft: left,\n    paddingRight: right,\n    paddingTop: top,\n    paddingBottom: bottom,\n  };\n};\n\nconst houseBounds: CameraBounds = {\n  ne: [-74.135379, 40.795909],\n  sw: [-74.135449, 40.795578],\n} as const;\n\nconst townBounds: CameraBounds = {\n  ne: [-74.12641, 40.797968],\n  sw: [-74.143727, 40.772177],\n} as const;\n\nconst houseCenter = [\n  (houseBounds.ne[0] + houseBounds.sw[0]) / 2,\n  (houseBounds.ne[1] + houseBounds.sw[1]) / 2,\n];\nconst townCenter = [\n  (townBounds.ne[0] + townBounds.sw[0]) / 2,\n  (townBounds.ne[1] + townBounds.sw[1]) / 2,\n];\n\nconst paddingZero = buildPadding();\nconst paddingTop = buildPadding([200, 40, 40, 40]);\nconst paddingBottom = buildPadding([40, 40, 200, 40]);\n\ntype PropsType = {};\n\nclass Fit extends React.Component {\n  camera: Camera | null = null;\n\n  state = {\n    locationType: 'houseCenter', // houseCenter | houseBounds | townCenter | townBounds\n    zoomLevel: 16, // number\n    followUserLocation: false,\n    padding: paddingZero,\n    animationDuration: 500,\n\n    // For updating the UI in this example.\n    cachedFlyTo: undefined, // house | town\n    cachedZoomLevel: undefined, // number\n  };\n\n  constructor(props: PropsType) {\n    super(props);\n  }\n\n  componentDidUpdate(_prevProps: PropsType, prevState: typeof this.state) {\n    const changed = (stateKey: keyof typeof this.state) => {\n      // Checking if final state is `undefined` prevents another round of zeroing out in\n      // second `componentDidUpdate` call.\n      return (\n        !isEqual(prevState[stateKey], this.state[stateKey]) &&\n        this.state[stateKey] !== undefined\n      );\n    };\n\n    if (changed('followUserLocation') && this.state.followUserLocation) {\n      this.setState({\n        locationType: undefined,\n        zoomLevel: undefined,\n        cachedFlyTo: undefined,\n        cachedZoomLevel: undefined,\n      });\n      return;\n    }\n\n    if (changed('locationType') || changed('zoomLevel') || changed('padding')) {\n      this.setState({\n        cachedFlyTo: undefined,\n        cachedZoomLevel: undefined,\n      });\n    } else if (changed('cachedFlyTo') || changed('cachedZoomLevel')) {\n      this.setState({\n        locationType: undefined,\n        zoomLevel: undefined,\n        padding: paddingZero,\n      });\n    }\n  }\n\n  renderSection(\n    title: string,\n    buttons: { title: string; selected: boolean; onPress: () => void }[],\n    fade = false,\n  ) {\n    return (\n      <View style={{ paddingBottom: 5, opacity: fade ? 0.5 : 1 }}>\n        <Text>{title}</Text>\n        <ScrollView\n          horizontal={true}\n          style={{\n            flex: 0,\n            flexDirection: 'row',\n            width: '100%',\n            paddingVertical: 10,\n          }}\n        >\n          {buttons.map((button) => (\n            <TouchableOpacity\n              key={button.title}\n              style={{\n                flex: 0,\n                padding: 5,\n                marginRight: 5,\n                backgroundColor: button.selected ? 'coral' : '#d8d8d8',\n                borderRadius: 5,\n              }}\n              onPress={button.onPress}\n            >\n              <Text>{button.title}</Text>\n            </TouchableOpacity>\n          ))}\n        </ScrollView>\n      </View>\n    );\n  }\n\n  cameraProps() {\n    const {\n      locationType,\n      zoomLevel,\n      followUserLocation,\n      padding,\n      animationDuration,\n    } = this.state;\n\n    let p: {\n      bounds?: CameraBounds;\n      centerCoordinate?: number[];\n      zoomLevel?: number;\n      followUserLocation: boolean;\n      padding: any;\n      animationDuration: number;\n    } = {\n      bounds: undefined,\n      centerCoordinate: undefined,\n      zoomLevel: undefined,\n      followUserLocation,\n      padding,\n      animationDuration,\n    };\n\n    if (locationType === 'houseCenter') {\n      p.centerCoordinate = houseCenter;\n    } else if (locationType === 'houseBounds') {\n      p.bounds = houseBounds;\n    } else if (locationType === 'townCenter') {\n      p.centerCoordinate = townCenter;\n    } else if (locationType === 'townBounds') {\n      p.bounds = townBounds;\n    }\n\n    if (zoomLevel !== undefined) {\n      p.zoomLevel = zoomLevel;\n    }\n\n    return p;\n  }\n\n  render() {\n    const {\n      locationType,\n      zoomLevel,\n      followUserLocation,\n      padding,\n      cachedFlyTo,\n      cachedZoomLevel,\n    } = this.state;\n\n    const centerIsSet = locationType?.toLowerCase().includes('center');\n\n    const locationTypeButtons = [\n      ['House (center)', 'houseCenter'],\n      ['House (bounds)', 'houseBounds'],\n      ['Town (center)', 'townCenter'],\n      ['Town (bounds)', 'townBounds'],\n      ['undef', undefined],\n    ].map((o) => {\n      return {\n        title: `${o[0]}`,\n        selected: locationType === o[1],\n        onPress: () => this.setState({ locationType: o[1] }),\n      };\n    });\n\n    const zoomConfigButtons = [14, 15, 16, 17, 18, 19, 20, undefined].map(\n      (n) => {\n        return {\n          title: n ? `${n}` : 'undef',\n          selected: zoomLevel === n,\n          onPress: () => this.setState({ zoomLevel: n }),\n        };\n      },\n    );\n\n    const zoomToButtons = [14, 15, 16, 17, 18, 19, 20].map((n) => {\n      return {\n        title: `${n}`,\n        selected: cachedZoomLevel === n,\n        onPress: () => {\n          assertCameraNotNull(this.camera);\n          this.camera.zoomTo(n, 1000);\n          this.setState({ cachedZoomLevel: n });\n        },\n      };\n    });\n\n    return (\n      <>\n        <MapView styleURL={StyleURL.Satellite} style={sheet.matchParent}>\n          <Camera\n            ref={(ref) => {\n              this.camera = ref;\n            }}\n            {...this.cameraProps()}\n          />\n          <View style={{ flex: 1, ...padding }}>\n            <View style={{ flex: 1, borderColor: 'white', borderWidth: 4 }} />\n          </View>\n        </MapView>\n\n        <ScrollView\n          style={{\n            flex: 0,\n            width: '100%',\n            maxHeight: 350,\n            backgroundColor: 'white',\n          }}\n          contentContainerStyle={{\n            padding: 10,\n            paddingBottom: 20,\n          }}\n        >\n          {this.renderSection('Location type', locationTypeButtons)}\n\n          {this.renderSection(\n            'Zoom' +\n              (centerIsSet ? '' : ' (only used if center coordinate is set)'),\n            zoomConfigButtons,\n            !centerIsSet,\n          )}\n\n          {this.renderSection('Follow user location', [\n            {\n              title: followUserLocation ? 'Enabled' : 'Disabled',\n              selected: followUserLocation,\n              onPress: () =>\n                this.setState({ followUserLocation: !followUserLocation }),\n            },\n          ])}\n\n          {this.renderSection('Fly to (imperative)', [\n            {\n              title: 'House',\n              selected: cachedFlyTo === 'house',\n              onPress: () => {\n                assertCameraNotNull(this.camera);\n                this.camera.flyTo(houseCenter);\n                this.setState({ cachedFlyTo: 'house' });\n              },\n            },\n            {\n              title: 'Town',\n              selected: cachedFlyTo === 'town',\n              onPress: () => {\n                assertCameraNotNull(this.camera);\n                this.camera.flyTo(townCenter);\n                this.setState({ cachedFlyTo: 'town' });\n              },\n            },\n          ])}\n\n          {this.renderSection('Zoom to (imperative)', zoomToButtons)}\n\n          {this.renderSection('Padding', [\n            {\n              title: 'None',\n              selected: isEqual(padding, paddingZero),\n              onPress: () => this.setState({ padding: paddingZero }),\n            },\n            {\n              title: 'Top',\n              selected: isEqual(padding, paddingTop),\n              onPress: () => this.setState({ padding: paddingTop }),\n            },\n            {\n              title: 'Bottom',\n              selected: isEqual(padding, paddingBottom),\n              onPress: () => this.setState({ padding: paddingBottom }),\n            },\n          ])}\n        </ScrollView>\n      </>\n    );\n  }\n}\n\nexport default Fit;\n\n"})}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.img,{alt:"Fit.png",src:t(9238).Z+"",width:"295",height:"640"}),"}"]})]})}function m(n={}){const{wrapper:e}={...(0,a.a)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(c,{...n})}):c(n)}},9238:(n,e,t)=>{t.d(e,{Z:()=>o});const o=t.p+"assets/images/Fit-4f3e8caf55e1bdb5d2e826d5f28913c3.png"},1151:(n,e,t)=>{t.d(e,{Z:()=>r,a:()=>i});var o=t(7294);const a={},s=o.createContext(a);function i(n){const e=o.useContext(s);return o.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:i(n.components),o.createElement(s.Provider,{value:e},n.children)}}}]);