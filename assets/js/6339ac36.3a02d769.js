"use strict";(self.webpackChunkmap_docs=self.webpackChunkmap_docs||[]).push([[7536],{3905:(n,e,t)=>{t.d(e,{Zo:()=>m,kt:()=>g});var o=t(7294);function a(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function r(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,o)}return t}function i(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?r(Object(t),!0).forEach((function(e){a(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function s(n,e){if(null==n)return{};var t,o,a=function(n,e){if(null==n)return{};var t,o,a={},r=Object.keys(n);for(o=0;o<r.length;o++)t=r[o],e.indexOf(t)>=0||(a[t]=n[t]);return a}(n,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);for(o=0;o<r.length;o++)t=r[o],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(a[t]=n[t])}return a}var d=o.createContext({}),l=function(n){var e=o.useContext(d),t=e;return n&&(t="function"==typeof n?n(e):i(i({},e),n)),t},m=function(n){var e=l(n.components);return o.createElement(d.Provider,{value:e},n.children)},c="mdxType",p={inlineCode:"code",wrapper:function(n){var e=n.children;return o.createElement(o.Fragment,{},e)}},u=o.forwardRef((function(n,e){var t=n.components,a=n.mdxType,r=n.originalType,d=n.parentName,m=s(n,["components","mdxType","originalType","parentName"]),c=l(t),u=a,g=c["".concat(d,".").concat(u)]||c[u]||p[u]||r;return t?o.createElement(g,i(i({ref:e},m),{},{components:t})):o.createElement(g,i({ref:e},m))}));function g(n,e){var t=arguments,a=e&&e.mdxType;if("string"==typeof n||a){var r=t.length,i=new Array(r);i[0]=u;var s={};for(var d in e)hasOwnProperty.call(e,d)&&(s[d]=e[d]);s.originalType=n,s[c]="string"==typeof n?n:a,i[1]=s;for(var l=2;l<r;l++)i[l]=t[l];return o.createElement.apply(null,i)}return o.createElement.apply(null,t)}u.displayName="MDXCreateElement"},8011:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>d,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var o=t(7462),a=(t(7294),t(3905));const r={title:"Camera Animation",tags:["Camera","Camera#animationMode"],custom_props:{example_rel_path:"V10/CameraAnimation.tsx"},custom_edit_url:"https://github.com/rnmapbox/maps/tree/master/example/src/examples/V10/CameraAnimation.tsx"},i=void 0,s={unversionedId:"examples/V10/CameraAnimation",id:"examples/V10/CameraAnimation",title:"Camera Animation",description:"Camera animation modes",source:"@site/docs/examples/V10/CameraAnimation.md",sourceDirName:"examples/V10",slug:"/examples/V10/CameraAnimation",permalink:"/docs/examples/V10/CameraAnimation",draft:!1,editUrl:"https://github.com/rnmapbox/maps/tree/master/example/src/examples/V10/CameraAnimation.tsx",tags:[{label:"Camera",permalink:"/docs/tags/camera"},{label:"Camera#animationMode",permalink:"/docs/tags/camera-animation-mode"}],version:"current",frontMatter:{title:"Camera Animation",tags:["Camera","Camera#animationMode"],custom_props:{example_rel_path:"V10/CameraAnimation.tsx"},custom_edit_url:"https://github.com/rnmapbox/maps/tree/master/example/src/examples/V10/CameraAnimation.tsx"},sidebar:"examplesSidebar",previous:{title:"User Location Updates",permalink:"/docs/examples/UserLocation/UserLocationUpdates"},next:{title:"Globe Projection",permalink:"/docs/examples/V10/GlobeProjection"}},d={},l=[],m={toc:l},c="wrapper";function p(n){let{components:e,...r}=n;return(0,a.kt)(c,(0,o.Z)({},m,r,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Camera animation modes"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"import { Divider, Text } from '@rneui/base';\nimport {\n  Camera,\n  CameraAnimationMode,\n  CameraBounds,\n  CameraPadding,\n  CircleLayer,\n  Logger,\n  MapView,\n  ShapeSource,\n} from '@rnmapbox/maps';\nimport bbox from '@turf/bbox';\nimport { Feature, Point, Position } from 'geojson';\nimport React, { useCallback, useMemo, useState } from 'react';\nimport { Button, SafeAreaView, StyleSheet, View } from 'react-native';\n\nimport colors from '../../styles/colors';\nimport { ExampleWithMetadata } from '../common/ExampleMetadata'; // exclude-from-doc\n\nLogger.setLogLevel('verbose');\n\ntype Coordinate = {\n  longitude: number;\n  latitude: number;\n};\n\nconst mapStyles = {\n  circle: {\n    circleRadius: 6,\n    circleColor: colors.primary.blue,\n  },\n};\n\nconst initialCoordinate: Coordinate = {\n  latitude: 40.759211,\n  longitude: -73.984638,\n};\n\nconst zeroPadding: CameraPadding = {\n  paddingTop: 0,\n  paddingBottom: 0,\n  paddingLeft: 0,\n  paddingRight: 0,\n};\nconst evenPadding: CameraPadding = {\n  paddingTop: 40,\n  paddingBottom: 40,\n  paddingLeft: 40,\n  paddingRight: 40,\n};\nconst minZoomLevel = 8;\nconst maxZoomLevel = 16;\n\nconst randPadding = (): CameraPadding => {\n  const randNum = () => {\n    const items = [0, 150, 300];\n    return items[Math.floor(Math.random() * items.length)];\n  };\n\n  return {\n    paddingTop: randNum(),\n    paddingBottom: randNum(),\n    paddingLeft: randNum(),\n    paddingRight: randNum(),\n  };\n};\n\nconst toPosition = (coordinate: Coordinate): Position => {\n  return [coordinate.longitude, coordinate.latitude];\n};\n\nconst CameraAnimation = () => {\n  const [animationMode, setAnimationMode] =\n    useState<CameraAnimationMode>('moveTo');\n  const [coordinates, setCoordinates] = useState<Coordinate[]>([\n    initialCoordinate,\n  ]);\n  const [padding, setPadding] = useState<CameraPadding>(zeroPadding);\n\n  const paddingDisplay = useMemo(() => {\n    return `L ${padding.paddingLeft} | R ${padding.paddingRight} | T ${padding.paddingTop} | B ${padding.paddingBottom}`;\n  }, [padding]);\n\n  const move = useCallback(\n    (_animationMode: CameraAnimationMode, shouldCreateMultiple: boolean) => {\n      setAnimationMode(_animationMode);\n\n      if (shouldCreateMultiple) {\n        const _centerCoordinate = {\n          latitude: initialCoordinate.latitude + Math.random() * 0.2,\n          longitude: initialCoordinate.longitude + Math.random() * 0.2,\n        };\n        const _coordinates = Array(10)\n          .fill(0)\n          .map((_) => {\n            return {\n              latitude: _centerCoordinate.latitude + Math.random() * 0.2,\n              longitude: _centerCoordinate.longitude + Math.random() * 0.2,\n            };\n          });\n        setCoordinates(_coordinates);\n      } else {\n        setCoordinates([\n          {\n            latitude: initialCoordinate.latitude + Math.random() * 0.2,\n            longitude: initialCoordinate.longitude + Math.random() * 0.2,\n          },\n        ]);\n      }\n    },\n    [],\n  );\n\n  const features = useMemo((): Feature<Point>[] => {\n    return coordinates.map((p) => {\n      const feature: Feature<Point> = {\n        type: 'Feature',\n        geometry: {\n          type: 'Point',\n          coordinates: toPosition(p),\n        },\n        properties: {},\n      };\n      return feature;\n    });\n  }, [coordinates]);\n\n  const centerOrBounds = useMemo((): {\n    centerCoordinate?: Position;\n    bounds?: CameraBounds;\n  } => {\n    if (coordinates.length === 1) {\n      return {\n        centerCoordinate: toPosition(coordinates[0]),\n      };\n    } else {\n      const positions = coordinates.map(toPosition);\n      const lineString = {\n        type: 'Feature',\n        geometry: {\n          type: 'LineString',\n          coordinates: positions,\n        },\n      };\n      const _bbox = bbox(lineString);\n      return {\n        bounds: {\n          ne: [_bbox[0], _bbox[1]],\n          sw: [_bbox[2], _bbox[3]],\n        },\n      };\n    }\n  }, [coordinates]);\n\n  const locationDisplay = useMemo(() => {\n    if (coordinates.length > 1) {\n      const ne = centerOrBounds.bounds?.ne.map((n) => n.toFixed(3));\n      const sw = centerOrBounds.bounds?.sw.map((n) => n.toFixed(3));\n      return `ne ${ne} | sw ${sw}`;\n    } else if (coordinates.length === 1) {\n      const lon = coordinates[0].longitude.toFixed(4);\n      const lat = coordinates[0].latitude.toFixed(4);\n      return `lon ${lon} | lat ${lat}`;\n    } else {\n      throw new Error('invalid location passed');\n    }\n  }, [coordinates, centerOrBounds]);\n\n  return (\n    <>\n      <MapView style={styles.map}>\n        <Camera\n          {...centerOrBounds}\n          zoomLevel={12}\n          minZoomLevel={minZoomLevel}\n          maxZoomLevel={maxZoomLevel}\n          padding={padding}\n          animationDuration={800}\n          animationMode={animationMode}\n        />\n\n        {features.map((feature) => {\n          const id = JSON.stringify(feature.geometry);\n          return (\n            <ShapeSource key={id} id={`source-${id}`} shape={feature}>\n              <CircleLayer id={`layer-${id}`} style={mapStyles.circle} />\n            </ShapeSource>\n          );\n        })}\n      </MapView>\n\n      <SafeAreaView>\n        <View style={styles.sheet}>\n          <View style={styles.content}>\n            <Text style={styles.fadedText}>centerCoordinate</Text>\n            <View style={styles.buttonRow}>\n              <Button title=\"Flight\" onPress={() => move('flyTo', false)} />\n              <Button title=\"Ease\" onPress={() => move('easeTo', false)} />\n              <Button title=\"Linear\" onPress={() => move('linearTo', false)} />\n              <Button title=\"Instant\" onPress={() => move('moveTo', false)} />\n            </View>\n\n            <Divider style={styles.divider} />\n\n            <Text style={styles.fadedText}>bounds</Text>\n            <View style={styles.buttonRow}>\n              <Button title=\"Flight\" onPress={() => move('flyTo', true)} />\n              <Button title=\"Ease\" onPress={() => move('easeTo', true)} />\n              <Button title=\"Linear\" onPress={() => move('linearTo', true)} />\n              <Button title=\"Instant\" onPress={() => move('moveTo', true)} />\n            </View>\n\n            <Divider style={styles.divider} />\n\n            <Text style={styles.fadedText}>padding</Text>\n            <View style={styles.buttonRow}>\n              <Button\n                title=\"Zero\"\n                onPress={() => {\n                  setPadding(zeroPadding);\n                }}\n              />\n              <Button\n                title=\"Even\"\n                onPress={() => {\n                  setPadding(evenPadding);\n                }}\n              />\n              <Button\n                title=\"Random\"\n                onPress={() => {\n                  setPadding(randPadding());\n                }}\n              />\n            </View>\n\n            <Divider style={styles.divider} />\n\n            <Text style={styles.fadedText}>info</Text>\n            <Text>position: {locationDisplay}</Text>\n            <Text>padding: {paddingDisplay}</Text>\n          </View>\n        </View>\n      </SafeAreaView>\n    </>\n  );\n};\n\nconst styles = StyleSheet.create({\n  map: {\n    flex: 1,\n  },\n  sheet: {\n    paddingTop: 10,\n    paddingHorizontal: 10,\n  },\n  content: {\n    padding: 10,\n  },\n  buttonRow: {\n    flex: 0,\n    flexDirection: 'row',\n    justifyContent: 'space-around',\n  },\n  divider: {\n    marginVertical: 10,\n  },\n  fadedText: {\n    color: 'gray',\n  },\n});\n\nexport default CameraAnimation;\n\n\n")),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"CameraAnimation.png",src:t(5846).Z,width:"295",height:"640"}),"}"))}p.isMDXComponent=!0},5846:(n,e,t)=>{t.d(e,{Z:()=>o});const o=t.p+"assets/images/CameraAnimation-fe82b61d5c59e3f1b21a2498235e9935.png"}}]);