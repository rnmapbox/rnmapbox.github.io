"use strict";(self.webpackChunkmap_docs=self.webpackChunkmap_docs||[]).push([[7536],{5612:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>d,contentTitle:()=>r,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>m});var o=t(5893),a=t(1151);const i={title:"Camera Animation",tags:["Camera","Camera#animationMode"],custom_props:{example_rel_path:"V10/CameraAnimation.tsx"},custom_edit_url:"https://github.com/rnmapbox/maps/tree/master/example/src/examples/V10/CameraAnimation.tsx"},r=void 0,s={id:"examples/V10/CameraAnimation",title:"Camera Animation",description:"Camera animation modes",source:"@site/docs/examples/V10/CameraAnimation.md",sourceDirName:"examples/V10",slug:"/examples/V10/CameraAnimation",permalink:"/docs/examples/V10/CameraAnimation",draft:!1,unlisted:!1,editUrl:"https://github.com/rnmapbox/maps/tree/master/example/src/examples/V10/CameraAnimation.tsx",tags:[{label:"Camera",permalink:"/docs/tags/camera"},{label:"Camera#animationMode",permalink:"/docs/tags/camera-animation-mode"}],version:"current",frontMatter:{title:"Camera Animation",tags:["Camera","Camera#animationMode"],custom_props:{example_rel_path:"V10/CameraAnimation.tsx"},custom_edit_url:"https://github.com/rnmapbox/maps/tree/master/example/src/examples/V10/CameraAnimation.tsx"},sidebar:"examplesSidebar",previous:{title:"User Location Updates",permalink:"/docs/examples/UserLocation/UserLocationUpdates"},next:{title:"Globe Projection",permalink:"/docs/examples/V10/GlobeProjection"}},d={},m=[];function l(n){const e={code:"code",img:"img",p:"p",pre:"pre",...(0,a.a)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.p,{children:"Camera animation modes"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:"import { Divider, Text } from '@rneui/base';\nimport {\n  Camera,\n  CameraAnimationMode,\n  CameraBounds,\n  CameraPadding,\n  CircleLayer,\n  Logger,\n  MapView,\n  ShapeSource,\n} from '@rnmapbox/maps';\nimport bbox from '@turf/bbox';\nimport { Feature, Point, Position } from 'geojson';\nimport React, { useCallback, useMemo, useState } from 'react';\nimport { Button, SafeAreaView, StyleSheet, View } from 'react-native';\n\nimport colors from '../../styles/colors';\nimport { ExampleWithMetadata } from '../common/ExampleMetadata'; // exclude-from-doc\n\nLogger.setLogLevel('verbose');\n\ntype Coordinate = {\n  longitude: number;\n  latitude: number;\n};\n\nconst mapStyles = {\n  circle: {\n    circleRadius: 6,\n    circleColor: colors.primary.blue,\n  },\n};\n\nconst initialCoordinate: Coordinate = {\n  latitude: 40.759211,\n  longitude: -73.984638,\n};\n\nconst zeroPadding: CameraPadding = {\n  paddingTop: 0,\n  paddingBottom: 0,\n  paddingLeft: 0,\n  paddingRight: 0,\n};\nconst evenPadding: CameraPadding = {\n  paddingTop: 40,\n  paddingBottom: 40,\n  paddingLeft: 40,\n  paddingRight: 40,\n};\nconst minZoomLevel = 8;\nconst maxZoomLevel = 16;\n\nconst randPadding = (): CameraPadding => {\n  const randNum = () => {\n    const items = [0, 150, 300];\n    return items[Math.floor(Math.random() * items.length)];\n  };\n\n  return {\n    paddingTop: randNum(),\n    paddingBottom: randNum(),\n    paddingLeft: randNum(),\n    paddingRight: randNum(),\n  };\n};\n\nconst toPosition = (coordinate: Coordinate): Position => {\n  return [coordinate.longitude, coordinate.latitude];\n};\n\nconst CameraAnimation = () => {\n  const [animationMode, setAnimationMode] =\n    useState<CameraAnimationMode>('moveTo');\n  const [coordinates, setCoordinates] = useState<Coordinate[]>([\n    initialCoordinate,\n  ]);\n  const [padding, setPadding] = useState<CameraPadding>(zeroPadding);\n\n  const paddingDisplay = useMemo(() => {\n    return `L ${padding.paddingLeft} | R ${padding.paddingRight} | T ${padding.paddingTop} | B ${padding.paddingBottom}`;\n  }, [padding]);\n\n  const move = useCallback(\n    (_animationMode: CameraAnimationMode, shouldCreateMultiple: boolean) => {\n      setAnimationMode(_animationMode);\n\n      if (shouldCreateMultiple) {\n        const _centerCoordinate = {\n          latitude: initialCoordinate.latitude + Math.random() * 0.2,\n          longitude: initialCoordinate.longitude + Math.random() * 0.2,\n        };\n        const _coordinates = Array(10)\n          .fill(0)\n          .map((_) => {\n            return {\n              latitude: _centerCoordinate.latitude + Math.random() * 0.2,\n              longitude: _centerCoordinate.longitude + Math.random() * 0.2,\n            };\n          });\n        setCoordinates(_coordinates);\n      } else {\n        setCoordinates([\n          {\n            latitude: initialCoordinate.latitude + Math.random() * 0.2,\n            longitude: initialCoordinate.longitude + Math.random() * 0.2,\n          },\n        ]);\n      }\n    },\n    [],\n  );\n\n  const features = useMemo((): Feature<Point>[] => {\n    return coordinates.map((p) => {\n      const feature: Feature<Point> = {\n        type: 'Feature',\n        geometry: {\n          type: 'Point',\n          coordinates: toPosition(p),\n        },\n        properties: {},\n      };\n      return feature;\n    });\n  }, [coordinates]);\n\n  const centerOrBounds = useMemo((): {\n    centerCoordinate?: Position;\n    bounds?: CameraBounds;\n  } => {\n    if (coordinates.length === 1) {\n      return {\n        centerCoordinate: toPosition(coordinates[0]),\n      };\n    } else {\n      const positions = coordinates.map(toPosition);\n      const lineString = {\n        type: 'Feature',\n        geometry: {\n          type: 'LineString',\n          coordinates: positions,\n        },\n      };\n      const _bbox = bbox(lineString);\n      return {\n        bounds: {\n          ne: [_bbox[0], _bbox[1]],\n          sw: [_bbox[2], _bbox[3]],\n        },\n      };\n    }\n  }, [coordinates]);\n\n  const locationDisplay = useMemo(() => {\n    if (coordinates.length > 1) {\n      const ne = centerOrBounds.bounds?.ne.map((n) => n.toFixed(3));\n      const sw = centerOrBounds.bounds?.sw.map((n) => n.toFixed(3));\n      return `ne ${ne} | sw ${sw}`;\n    } else if (coordinates.length === 1) {\n      const lon = coordinates[0].longitude.toFixed(4);\n      const lat = coordinates[0].latitude.toFixed(4);\n      return `lon ${lon} | lat ${lat}`;\n    } else {\n      throw new Error('invalid location passed');\n    }\n  }, [coordinates, centerOrBounds]);\n\n  return (\n    <>\n      <MapView style={styles.map}>\n        <Camera\n          {...centerOrBounds}\n          zoomLevel={12}\n          minZoomLevel={minZoomLevel}\n          maxZoomLevel={maxZoomLevel}\n          padding={padding}\n          animationDuration={800}\n          animationMode={animationMode}\n        />\n\n        {features.map((feature) => {\n          const id = JSON.stringify(feature.geometry);\n          return (\n            <ShapeSource key={id} id={`source-${id}`} shape={feature}>\n              <CircleLayer id={`layer-${id}`} style={mapStyles.circle} />\n            </ShapeSource>\n          );\n        })}\n      </MapView>\n\n      <SafeAreaView>\n        <View style={styles.sheet}>\n          <View style={styles.content}>\n            <Text style={styles.fadedText}>centerCoordinate</Text>\n            <View style={styles.buttonRow}>\n              <Button title=\"Flight\" onPress={() => move('flyTo', false)} />\n              <Button title=\"Ease\" onPress={() => move('easeTo', false)} />\n              <Button title=\"Linear\" onPress={() => move('linearTo', false)} />\n              <Button title=\"Instant\" onPress={() => move('moveTo', false)} />\n            </View>\n\n            <Divider style={styles.divider} />\n\n            <Text style={styles.fadedText}>bounds</Text>\n            <View style={styles.buttonRow}>\n              <Button title=\"Flight\" onPress={() => move('flyTo', true)} />\n              <Button title=\"Ease\" onPress={() => move('easeTo', true)} />\n              <Button title=\"Linear\" onPress={() => move('linearTo', true)} />\n              <Button title=\"Instant\" onPress={() => move('moveTo', true)} />\n            </View>\n\n            <Divider style={styles.divider} />\n\n            <Text style={styles.fadedText}>padding</Text>\n            <View style={styles.buttonRow}>\n              <Button\n                title=\"Zero\"\n                onPress={() => {\n                  setPadding(zeroPadding);\n                }}\n              />\n              <Button\n                title=\"Even\"\n                onPress={() => {\n                  setPadding(evenPadding);\n                }}\n              />\n              <Button\n                title=\"Random\"\n                onPress={() => {\n                  setPadding(randPadding());\n                }}\n              />\n            </View>\n\n            <Divider style={styles.divider} />\n\n            <Text style={styles.fadedText}>info</Text>\n            <Text>position: {locationDisplay}</Text>\n            <Text>padding: {paddingDisplay}</Text>\n          </View>\n        </View>\n      </SafeAreaView>\n    </>\n  );\n};\n\nconst styles = StyleSheet.create({\n  map: {\n    flex: 1,\n  },\n  sheet: {\n    paddingTop: 10,\n    paddingHorizontal: 10,\n  },\n  content: {\n    padding: 10,\n  },\n  buttonRow: {\n    flex: 0,\n    flexDirection: 'row',\n    justifyContent: 'space-around',\n  },\n  divider: {\n    marginVertical: 10,\n  },\n  fadedText: {\n    color: 'gray',\n  },\n});\n\nexport default CameraAnimation;\n\n\n"})}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.img,{alt:"CameraAnimation.png",src:t(5846).Z+"",width:"295",height:"640"}),"}"]})]})}function c(n={}){const{wrapper:e}={...(0,a.a)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(l,{...n})}):l(n)}},5846:(n,e,t)=>{t.d(e,{Z:()=>o});const o=t.p+"assets/images/CameraAnimation-5592217ea9628298d58bd7df23c0d712.png"},1151:(n,e,t)=>{t.d(e,{Z:()=>s,a:()=>r});var o=t(7294);const a={},i=o.createContext(a);function r(n){const e=o.useContext(i);return o.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:r(n.components),o.createElement(i.Provider,{value:e},n.children)}}}]);